#!/usr/bin/env node
import {
  buildSitemap,
  buildSitemapIndex,
  buildSitemaps,
  getConfig,
  getRobots
} from "./chunk-ZNF4YBVV.mjs";

// src/bin/index.ts
import path4 from "path";
import fs3 from "fs";

// src/bin/routes.ts
import { readConfig } from "@remix-run/dev/dist/config.js";
import path2 from "path";

// src/bin/moduleBuilder.ts
import { build } from "esbuild";
import path from "path";
import fs from "fs";
var dir = path.resolve(process.cwd());
var cleanAssetsPlugin = {
  name: "clean-assets",
  setup(build2) {
    build2.onResolve(
      {
        filter: /\.(png|jpg|jpeg|gif|svg|webp|ico|woff|woff2|ttf|otf|eot|mp4|webm|wav|mp3|m4a|aac|oga|pdf)$/
      },
      (args) => ({
        path: args.path,
        namespace: "clean-assets"
      })
    );
    build2.onLoad({ filter: /.*/, namespace: "clean-assets" }, () => ({
      contents: "",
      loader: "js"
    }));
  }
};
var cleanStylesPlugin = {
  name: "clean-styles",
  setup(build2) {
    build2.onResolve({ filter: /\.css$/ }, (args) => ({
      path: args.path,
      namespace: "clean-styles"
    }));
    build2.onLoad({ filter: /.*/, namespace: "clean-styles" }, () => ({
      contents: "",
      loader: "js"
    }));
  }
};
async function createModuleBuilder() {
  const plugins = [cleanStylesPlugin, cleanAssetsPlugin];
  const tsconfig = path.resolve(dir, "tsconfig.json");
  const isTsProject = fs.existsSync(tsconfig);
  if (isTsProject) {
    const { TsconfigPathsPlugin } = await import("@esbuild-plugins/tsconfig-paths");
    plugins.push(TsconfigPathsPlugin({ tsconfig }));
  }
  return {
    buildModule: (file) => buildModule(file, plugins)
  };
}
function buildModule(file, plugins) {
  return build({
    entryPoints: [file],
    platform: "neutral",
    format: "cjs",
    outfile: "out.js",
    write: false,
    bundle: true,
    packages: "external",
    loader: {
      ".js": "jsx"
    },
    logLevel: "silent",
    plugins
  });
}

// src/bin/routes.ts
import requireFromString from "require-from-string";
var dir2 = path2.resolve(process.cwd());
async function getRoutesAndModules() {
  const config = await readConfig(process.env.REMIX_ROOT || dir2);
  const routes = config.routes;
  const modules = {};
  console.log("\u{1F50D} Found routes: " + Object.keys(routes).join(", "));
  const { buildModule: buildModule2 } = await createModuleBuilder();
  await Promise.all(
    Object.keys(routes).map(async (key) => {
      const route = routes[key];
      if (key === "root")
        return;
      const file = path2.resolve(config.appDirectory, route.file);
      const result = await buildModule2(file);
      const module = requireFromString(result.outputFiles[0].text);
      modules[key] = module;
    })
  );
  return {
    routes,
    modules
  };
}

// src/bin/polyfill.ts
import "isomorphic-fetch";

// src/bin/files.ts
import fs2 from "fs";
import path3 from "path";
var dir3 = process.cwd();
function createIndexSitemapFile(sitemap, config) {
  const sitemaps = Array.isArray(sitemap) ? sitemap.map((_, index) => `${config.sitemapBaseFileName}-${index}.xml`) : [`${config.sitemapBaseFileName}-0.xml`];
  const sitemapIndex = buildSitemapIndex(sitemaps, config);
  fs2.writeFileSync(path3.join(dir3, config.outDir, "sitemap.xml"), sitemapIndex);
}
function createSitemapFiles(sitemap, config) {
  if (Array.isArray(sitemap)) {
    sitemap.forEach((content, index) => {
      fs2.writeFileSync(
        path3.join(
          dir3,
          config.outDir,
          `${config.sitemapBaseFileName}-${index}.xml`
        ),
        content
      );
    });
  } else {
    const filename = config.generateIndexSitemap ? `${config.sitemapBaseFileName}-0.xml` : `${config.sitemapBaseFileName}.xml`;
    fs2.writeFileSync(path3.join(dir3, config.outDir, filename), sitemap);
  }
}
function createRobotsFile(config) {
  const robots = getRobots(config);
  fs2.writeFileSync(path3.join(dir3, config.outDir, "robots.txt"), robots);
}
function deleteOldSitemaps(config) {
  const files = fs2.readdirSync(path3.join(dir3, config.outDir));
  const sitemaps = files.filter(
    (file) => file.startsWith(config.sitemapBaseFileName)
  );
  sitemaps.forEach((sitemap) => {
    fs2.unlinkSync(path3.join(dir3, config.outDir, sitemap));
  });
}

// src/bin/index.ts
import { pathToFileURL } from "url";
var findConfig = () => {
  const configPath = path4.resolve(process.cwd(), "remix-sitemap.config.js");
  if (fs3.existsSync(configPath))
    return pathToFileURL(configPath).toString();
};
async function main() {
  const configPath = findConfig();
  if (!configPath) {
    console.error("\u274C No config file found");
    return;
  }
  console.log("\u{1F50D} Found config file:", configPath);
  const { default: configFile } = await import(configPath);
  const config = getConfig(configFile);
  console.log("\u{1F50D} Generating sitemap...");
  const { routes, modules } = await getRoutesAndModules();
  const params = {
    config,
    context: {
      routeModules: modules,
      manifest: {
        routes
      }
    },
    request: {}
  };
  const isSplitted = config.size && config.size > 0;
  const sitemap = isSplitted ? await buildSitemaps(params) : await buildSitemap(params);
  if (config.generateRobotsTxt) {
    createRobotsFile(config);
  }
  deleteOldSitemaps(config);
  if (config.generateIndexSitemap) {
    createIndexSitemapFile(sitemap, config);
  }
  createSitemapFiles(sitemap, config);
  console.log("\u2728 Sitemap generated successfully");
}
main();
