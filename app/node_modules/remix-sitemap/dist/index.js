"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createSitemapGenerator: () => createSitemapGenerator
});
module.exports = __toCommonJS(src_exports);

// src/builders/sitemap.ts
var import_ufo2 = require("ufo");
var import_fast_xml_parser = require("fast-xml-parser");

// src/utils/xml.ts
var getBooleanValue = (value) => typeof value !== "boolean" ? void 0 : value ? "yes" : "no";
function getOptionalValue(value, returnType) {
  return !value ? void 0 : returnType;
}

// src/utils/rate-limiter.ts
var RateLimiter = class {
  constructor(rate) {
    this.rate = rate;
    this.queue = [];
    this.active = 0;
  }
  allocate() {
    return new Promise((res) => {
      if (this.active < this.rate) {
        this.active++;
        res();
      } else {
        this.queue.push(res);
      }
    });
  }
  free() {
    const first = this.queue.shift();
    if (first) {
      first();
    } else {
      this.active = Math.max(0, this.active - 1);
    }
  }
  getProcessing() {
    return this.active;
  }
  getWaiting() {
    return this.queue.length;
  }
};

// src/utils/data.ts
function getRouteData(route, context) {
  var _a;
  const manifest = context.manifest.routes[route];
  const module2 = context.routeModules[route];
  const path = getFullPath(route, context.manifest.routes);
  const parents = (_a = manifest.id) == null ? void 0 : _a.split("/").slice(0, -1);
  const parentId = parents.join("/");
  return {
    manifest,
    module: module2,
    modules: context.routeModules,
    sitemapFunction: module2 == null ? void 0 : module2.sitemap,
    path,
    parents,
    parentId
  };
}
function getFullPath(route, routes) {
  const manifest = routes[route];
  if (manifest.index) {
    const parent2 = getFullPath(manifest.parentId || "root", routes);
    if (!manifest.path && !parent2)
      return "";
    if (manifest.path && parent2)
      return `${parent2}/${manifest.path}`;
    return manifest.path;
  }
  if (!manifest.parentId || manifest.parentId === "root" || !manifest.path)
    return manifest.path;
  const parent = getFullPath(manifest.parentId, routes);
  if (parent)
    return `${parent}/${manifest.path}`;
  return manifest.path;
}

// src/utils/validations.ts
var import_ufo = require("ufo");
function isSitemapUrl(config, request) {
  const url = new URL(request.url);
  return (0, import_ufo.isEqual)(url.pathname, `/${config.sitemapBaseFileName}.xml`);
}
var isDynamicPath = (path) => (path == null ? void 0 : path.includes(":")) || (path == null ? void 0 : path.includes("*"));
var isRobotsUrl = (request) => {
  const url = new URL(request.url);
  return (0, import_ufo.isEqual)(url.pathname, `/robots.txt`);
};
function isValidEntry(route, context) {
  const { manifest, path, module: module2, sitemapFunction } = getRouteData(
    route,
    context
  );
  if (manifest.id === "root")
    return false;
  if (typeof path === "undefined" && !sitemapFunction)
    return false;
  if (!module2.default && !sitemapFunction)
    return false;
  if (isDynamicPath(path) && !sitemapFunction)
    return false;
  return true;
}

// src/utils/entries.ts
async function getEntry(params) {
  const { route, context, request, config } = params;
  if (!isValidEntry(route, context))
    return null;
  const { sitemapFunction, path } = getRouteData(route, context);
  const sitemap = sitemapFunction ? await sitemapFunction({ request, config }) : null;
  if (sitemap) {
    if (Array.isArray(sitemap)) {
      const notExcluded = sitemap.filter((entry) => !entry.exclude);
      return notExcluded.map((entry) => buildSitemapUrl({ config, entry }));
    }
    if (sitemap.exclude)
      return null;
    return buildSitemapUrl({
      config,
      entry: { ...sitemap, loc: sitemap.loc || path }
    });
  }
  return buildSitemapUrl({ config, entry: { loc: path } });
}

// src/utils/truthy.ts
function truthy(value) {
  return !!value;
}

// src/builders/sitemap.ts
var getAlternateRef = (alternateRefs) => ({
  "@_rel": "alternate",
  "@_hreflang": alternateRefs.hreflang,
  "@_href": (0, import_ufo2.cleanDoubleSlashes)(alternateRefs.href)
});
var getImage = (image) => ({
  "image:loc": image.loc
});
var getVideo = (video) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  return {
    "video:thumbnail_loc": video.thumbnailLoc,
    "video:title": video.title,
    "video:description": video.description,
    "video:content_loc": video.contentLoc,
    "video:player_loc": video.playerLoc,
    "video:duration": video.duration,
    "video:expiration_date": video.expirationDate,
    "video:rating": video.rating,
    "video:view_count": video.viewCount,
    "video:publication_date": video.publicationDate,
    "video:family_friendly": getBooleanValue(video.familyFriendly),
    "video:restriction": getOptionalValue(video.restriction, {
      "@_relationship": (_a = video.restriction) == null ? void 0 : _a.relationship,
      "#text": (_b = video.restriction) == null ? void 0 : _b.countries.join(" ")
    }),
    "video:price": getOptionalValue(video.price, {
      "@_currency": (_c = video.price) == null ? void 0 : _c.currency,
      "#text": (_d = video.price) == null ? void 0 : _d.value
    }),
    "video:requires_subscription": getBooleanValue(video.requiresSubscription),
    "video:platform": getOptionalValue(video.platform, {
      "@_relationship": (_e = video.platform) == null ? void 0 : _e.relationship,
      "#text": (_g = (_f = video.platform) == null ? void 0 : _f.content) == null ? void 0 : _g.join(" ")
    }),
    "video:uploader": getOptionalValue(video.uploader, {
      "@_info": (_h = video.uploader) == null ? void 0 : _h.info,
      "#text": (_i = video.uploader) == null ? void 0 : _i.name
    }),
    "video:live": getBooleanValue(video.live),
    "video:tag": video.tags
  };
};
var getNews = (news) => ({
  "news:publication": {
    "news:name": news.publication.name,
    "news:language": news.publication.language
  },
  "news:publication_date": news.date,
  "news:title": news.title
});
var getUrl = (entry) => {
  var _a, _b, _c, _d;
  return {
    loc: (0, import_ufo2.cleanDoubleSlashes)(entry.loc),
    lastmod: entry.lastmod,
    changefreq: entry.changefreq,
    priority: entry.priority,
    "xhtml:link": (_a = entry.alternateRefs) == null ? void 0 : _a.map(getAlternateRef),
    "image:image": (_b = entry.images) == null ? void 0 : _b.map(getImage),
    "news:news": (_c = entry.news) == null ? void 0 : _c.map(getNews),
    "video:video": (_d = entry.videos) == null ? void 0 : _d.map(getVideo)
  };
};
function buildSitemapUrl({ config, entry }) {
  var _a, _b, _c, _d;
  const alternateRefs = (_a = (entry == null ? void 0 : entry.alternateRefs) || config.alternateRefs) == null ? void 0 : _a.map(
    (ref) => ({
      ...ref,
      href: ref.absolute ? ref.href : `${ref.href}/${entry == null ? void 0 : entry.loc}`
    })
  );
  const url = getUrl({
    loc: `${config.siteUrl}/${entry == null ? void 0 : entry.loc}`,
    lastmod: config.autoLastmod ? (_b = entry == null ? void 0 : entry.lastmod) != null ? _b : (/* @__PURE__ */ new Date()).toISOString() : entry == null ? void 0 : entry.lastmod,
    changefreq: (_c = entry == null ? void 0 : entry.changefreq) != null ? _c : config.changefreq,
    priority: (_d = entry == null ? void 0 : entry.priority) != null ? _d : config.priority,
    alternateRefs,
    videos: entry == null ? void 0 : entry.videos,
    images: entry == null ? void 0 : entry.images,
    news: entry == null ? void 0 : entry.news
  });
  return url;
}
function buildSitemapXml(urlset, format) {
  const builder = new import_fast_xml_parser.XMLBuilder({
    suppressEmptyNode: true,
    ignoreAttributes: false,
    processEntities: true,
    format
  });
  return builder.build({
    "?xml": {
      "@_version": "1.0",
      "@_encoding": "UTF-8"
    },
    urlset: {
      "@_xmlns": "http://www.sitemaps.org/schemas/sitemap/0.9",
      "@_xmlns:news": "http://www.google.com/schemas/sitemap-news/0.9",
      "@_xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "@_xmlns:image": "http://www.google.com/schemas/sitemap-image/1.1",
      "@_xmlns:video": "http://www.google.com/schemas/sitemap-video/1.1",
      url: urlset
    }
  });
}
async function IngestRoutes(params) {
  const { config, context, request } = params;
  const routes = Object.keys(context.manifest.routes);
  if (config.rateLimit) {
    const limiter = new RateLimiter(config.rateLimit);
    const entriesPromise = routes.map(async (route) => {
      await limiter.allocate();
      const out = await getEntry({ route, config, context, request });
      limiter.free();
      return out;
    });
    return (await Promise.all(entriesPromise)).flat().filter(truthy);
  } else {
    const entriesPromise = routes.map(
      (route) => getEntry({ route, config, context, request })
    );
    return (await Promise.all(entriesPromise)).flat().filter(truthy);
  }
}
async function buildSitemap(params) {
  const entries = await IngestRoutes(params);
  return buildSitemapXml(entries, params.config.format);
}

// src/sitemap.ts
async function sitemapResponse(config, request, context) {
  const { cache } = config;
  if (cache) {
    const cached = await cache.get();
    if (cached) {
      const bytes2 = new TextEncoder().encode(cached).byteLength;
      return new Response(cached, {
        headers: {
          ...config.headers || {},
          "Content-Type": "application/xml",
          "Content-Length": bytes2.toString()
        }
      });
    }
  }
  const sitemap = await buildSitemap({
    config,
    context,
    request
  });
  if (cache)
    await cache.set(sitemap);
  const bytes = new TextEncoder().encode(sitemap).byteLength;
  return new Response(sitemap, {
    headers: {
      ...config.headers || {},
      "Content-Type": "application/xml",
      "Content-Length": bytes.toString()
    }
  });
}

// src/lib/config.ts
var getConfig = (config) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    ...config,
    autoLastmod: (_a = config.autoLastmod) != null ? _a : true,
    changefreq: (_b = config.changefreq) != null ? _b : "daily",
    priority: (_c = config.priority) != null ? _c : 0.7,
    sitemapBaseFileName: (_d = config.sitemapBaseFileName) != null ? _d : "sitemap",
    generateIndexSitemap: (_e = config.generateIndexSitemap) != null ? _e : true,
    outDir: (_f = config.outDir) != null ? _f : "public",
    robotsTxtOptions: {
      ...config.robotsTxtOptions || {},
      policies: (_h = (_g = config.robotsTxtOptions) == null ? void 0 : _g.policies) != null ? _h : [
        {
          userAgent: "*",
          allow: "/"
        }
      ]
    }
  };
};

// src/robots.ts
function getPolicy(policy) {
  const { allow, disallow, userAgent } = policy;
  let policyStr = `# ${userAgent}
User-agent: ${userAgent}`;
  if (allow) {
    const allowStr = Array.isArray(allow) ? allow.join("\nAllow: ") : allow;
    policyStr += `
Allow: ${allowStr}`;
  }
  if (disallow) {
    const disallowStr = Array.isArray(disallow) ? disallow.join("\nDisallow: ") : disallow;
    policyStr += `
Disallow: ${disallowStr}`;
  }
  return policyStr;
}
function getSitemap(sitemap) {
  return `Sitemap: ${sitemap}`;
}
function getRobots(config) {
  var _a;
  const options = config.robotsTxtOptions;
  let str = "";
  const policies = (_a = options == null ? void 0 : options.policies) == null ? void 0 : _a.map(getPolicy);
  if (policies == null ? void 0 : policies.length) {
    str += policies.join("\n\n");
    str += "\n\n";
  }
  str += `# Host
Host: ${config.siteUrl}

`;
  const sitemaps = [`${config.siteUrl}/${config.sitemapBaseFileName}.xml`].concat((options == null ? void 0 : options.additionalSitemaps) || []).map(getSitemap);
  if (sitemaps == null ? void 0 : sitemaps.length) {
    str += "# Sitemaps\n";
    str += sitemaps.join("\n");
  }
  return str;
}
function robotsResponse(config) {
  const robots = getRobots(config);
  if (!robots)
    return;
  const bytes = new TextEncoder().encode(robots).byteLength;
  return new Response(robots, {
    headers: {
      ...config.headers || {},
      "Content-Type": "text/plain",
      "Content-Length": bytes.toString()
    }
  });
}

// src/index.ts
var createSitemapGenerator = (config) => {
  const defaultConfig = getConfig(config);
  return {
    sitemap: (request, context) => {
      if (isSitemapUrl(defaultConfig, request)) {
        return sitemapResponse(defaultConfig, request, context);
      }
      if (defaultConfig.generateRobotsTxt && isRobotsUrl(request)) {
        return robotsResponse(defaultConfig);
      }
    },
    robots: () => robotsResponse(defaultConfig),
    experimental_sitemap: (request, routes) => {
      const routeModules = Object.keys(routes).reduce(
        (acc, route) => ({
          ...acc,
          [route]: routes[route].module
        }),
        {}
      );
      return sitemapResponse(defaultConfig, request, {
        routeModules,
        manifest: {
          routes
        }
      });
    },
    isSitemapUrl: (request) => isSitemapUrl(defaultConfig, request) || defaultConfig.generateRobotsTxt && isRobotsUrl(request)
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createSitemapGenerator
});
