#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/bin/index.ts
var import_path4 = __toESM(require("path"));
var import_fs3 = __toESM(require("fs"));

// src/builders/sitemap.ts
var import_ufo2 = require("ufo");
var import_fast_xml_parser = require("fast-xml-parser");

// src/utils/xml.ts
var getBooleanValue = (value) => typeof value !== "boolean" ? void 0 : value ? "yes" : "no";
function getOptionalValue(value, returnType) {
  return !value ? void 0 : returnType;
}

// src/utils/rate-limiter.ts
var RateLimiter = class {
  constructor(rate) {
    this.rate = rate;
    this.queue = [];
    this.active = 0;
  }
  allocate() {
    return new Promise((res) => {
      if (this.active < this.rate) {
        this.active++;
        res();
      } else {
        this.queue.push(res);
      }
    });
  }
  free() {
    const first = this.queue.shift();
    if (first) {
      first();
    } else {
      this.active = Math.max(0, this.active - 1);
    }
  }
  getProcessing() {
    return this.active;
  }
  getWaiting() {
    return this.queue.length;
  }
};

// src/utils/data.ts
function getRouteData(route, context) {
  var _a;
  const manifest = context.manifest.routes[route];
  const module2 = context.routeModules[route];
  const path5 = getFullPath(route, context.manifest.routes);
  const parents = (_a = manifest.id) == null ? void 0 : _a.split("/").slice(0, -1);
  const parentId = parents.join("/");
  return {
    manifest,
    module: module2,
    modules: context.routeModules,
    sitemapFunction: module2 == null ? void 0 : module2.sitemap,
    path: path5,
    parents,
    parentId
  };
}
function getFullPath(route, routes) {
  const manifest = routes[route];
  if (manifest.index) {
    const parent2 = getFullPath(manifest.parentId || "root", routes);
    if (!manifest.path && !parent2)
      return "";
    if (manifest.path && parent2)
      return `${parent2}/${manifest.path}`;
    return manifest.path;
  }
  if (!manifest.parentId || manifest.parentId === "root" || !manifest.path)
    return manifest.path;
  const parent = getFullPath(manifest.parentId, routes);
  if (parent)
    return `${parent}/${manifest.path}`;
  return manifest.path;
}

// src/utils/validations.ts
var import_ufo = require("ufo");
var isDynamicPath = (path5) => (path5 == null ? void 0 : path5.includes(":")) || (path5 == null ? void 0 : path5.includes("*"));
function isValidEntry(route, context) {
  const { manifest, path: path5, module: module2, sitemapFunction } = getRouteData(
    route,
    context
  );
  if (manifest.id === "root")
    return false;
  if (typeof path5 === "undefined" && !sitemapFunction)
    return false;
  if (!module2.default && !sitemapFunction)
    return false;
  if (isDynamicPath(path5) && !sitemapFunction)
    return false;
  return true;
}

// src/utils/entries.ts
async function getEntry(params) {
  const { route, context, request, config } = params;
  if (!isValidEntry(route, context))
    return null;
  const { sitemapFunction, path: path5 } = getRouteData(route, context);
  const sitemap = sitemapFunction ? await sitemapFunction({ request, config }) : null;
  if (sitemap) {
    if (Array.isArray(sitemap)) {
      const notExcluded = sitemap.filter((entry) => !entry.exclude);
      return notExcluded.map((entry) => buildSitemapUrl({ config, entry }));
    }
    if (sitemap.exclude)
      return null;
    return buildSitemapUrl({
      config,
      entry: { ...sitemap, loc: sitemap.loc || path5 }
    });
  }
  return buildSitemapUrl({ config, entry: { loc: path5 } });
}

// src/utils/truthy.ts
function truthy(value) {
  return !!value;
}

// src/utils/chunk.ts
function chunk(arr, chunkSize) {
  const R = [];
  for (let i = 0, len = arr.length; i < len; i += chunkSize)
    R.push(arr.slice(i, i + chunkSize));
  return R;
}

// src/builders/sitemap.ts
var getAlternateRef = (alternateRefs) => ({
  "@_rel": "alternate",
  "@_hreflang": alternateRefs.hreflang,
  "@_href": (0, import_ufo2.cleanDoubleSlashes)(alternateRefs.href)
});
var getImage = (image) => ({
  "image:loc": image.loc
});
var getVideo = (video) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  return {
    "video:thumbnail_loc": video.thumbnailLoc,
    "video:title": video.title,
    "video:description": video.description,
    "video:content_loc": video.contentLoc,
    "video:player_loc": video.playerLoc,
    "video:duration": video.duration,
    "video:expiration_date": video.expirationDate,
    "video:rating": video.rating,
    "video:view_count": video.viewCount,
    "video:publication_date": video.publicationDate,
    "video:family_friendly": getBooleanValue(video.familyFriendly),
    "video:restriction": getOptionalValue(video.restriction, {
      "@_relationship": (_a = video.restriction) == null ? void 0 : _a.relationship,
      "#text": (_b = video.restriction) == null ? void 0 : _b.countries.join(" ")
    }),
    "video:price": getOptionalValue(video.price, {
      "@_currency": (_c = video.price) == null ? void 0 : _c.currency,
      "#text": (_d = video.price) == null ? void 0 : _d.value
    }),
    "video:requires_subscription": getBooleanValue(video.requiresSubscription),
    "video:platform": getOptionalValue(video.platform, {
      "@_relationship": (_e = video.platform) == null ? void 0 : _e.relationship,
      "#text": (_g = (_f = video.platform) == null ? void 0 : _f.content) == null ? void 0 : _g.join(" ")
    }),
    "video:uploader": getOptionalValue(video.uploader, {
      "@_info": (_h = video.uploader) == null ? void 0 : _h.info,
      "#text": (_i = video.uploader) == null ? void 0 : _i.name
    }),
    "video:live": getBooleanValue(video.live),
    "video:tag": video.tags
  };
};
var getNews = (news) => ({
  "news:publication": {
    "news:name": news.publication.name,
    "news:language": news.publication.language
  },
  "news:publication_date": news.date,
  "news:title": news.title
});
var getUrl = (entry) => {
  var _a, _b, _c, _d;
  return {
    loc: (0, import_ufo2.cleanDoubleSlashes)(entry.loc),
    lastmod: entry.lastmod,
    changefreq: entry.changefreq,
    priority: entry.priority,
    "xhtml:link": (_a = entry.alternateRefs) == null ? void 0 : _a.map(getAlternateRef),
    "image:image": (_b = entry.images) == null ? void 0 : _b.map(getImage),
    "news:news": (_c = entry.news) == null ? void 0 : _c.map(getNews),
    "video:video": (_d = entry.videos) == null ? void 0 : _d.map(getVideo)
  };
};
function buildSitemapUrl({ config, entry }) {
  var _a, _b, _c, _d;
  const alternateRefs = (_a = (entry == null ? void 0 : entry.alternateRefs) || config.alternateRefs) == null ? void 0 : _a.map(
    (ref) => ({
      ...ref,
      href: ref.absolute ? ref.href : `${ref.href}/${entry == null ? void 0 : entry.loc}`
    })
  );
  const url = getUrl({
    loc: `${config.siteUrl}/${entry == null ? void 0 : entry.loc}`,
    lastmod: config.autoLastmod ? (_b = entry == null ? void 0 : entry.lastmod) != null ? _b : (/* @__PURE__ */ new Date()).toISOString() : entry == null ? void 0 : entry.lastmod,
    changefreq: (_c = entry == null ? void 0 : entry.changefreq) != null ? _c : config.changefreq,
    priority: (_d = entry == null ? void 0 : entry.priority) != null ? _d : config.priority,
    alternateRefs,
    videos: entry == null ? void 0 : entry.videos,
    images: entry == null ? void 0 : entry.images,
    news: entry == null ? void 0 : entry.news
  });
  return url;
}
function buildSitemapXml(urlset, format) {
  const builder = new import_fast_xml_parser.XMLBuilder({
    suppressEmptyNode: true,
    ignoreAttributes: false,
    processEntities: true,
    format
  });
  return builder.build({
    "?xml": {
      "@_version": "1.0",
      "@_encoding": "UTF-8"
    },
    urlset: {
      "@_xmlns": "http://www.sitemaps.org/schemas/sitemap/0.9",
      "@_xmlns:news": "http://www.google.com/schemas/sitemap-news/0.9",
      "@_xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "@_xmlns:image": "http://www.google.com/schemas/sitemap-image/1.1",
      "@_xmlns:video": "http://www.google.com/schemas/sitemap-video/1.1",
      url: urlset
    }
  });
}
async function IngestRoutes(params) {
  const { config, context, request } = params;
  const routes = Object.keys(context.manifest.routes);
  if (config.rateLimit) {
    const limiter = new RateLimiter(config.rateLimit);
    const entriesPromise = routes.map(async (route) => {
      await limiter.allocate();
      const out = await getEntry({ route, config, context, request });
      limiter.free();
      return out;
    });
    return (await Promise.all(entriesPromise)).flat().filter(truthy);
  } else {
    const entriesPromise = routes.map(
      (route) => getEntry({ route, config, context, request })
    );
    return (await Promise.all(entriesPromise)).flat().filter(truthy);
  }
}
async function buildSitemap(params) {
  const entries = await IngestRoutes(params);
  return buildSitemapXml(entries, params.config.format);
}
async function buildSitemaps(params) {
  if (!params.config.size)
    throw new Error("You must specify a size for sitemap splitting");
  const entries = await IngestRoutes(params);
  const sitemaps = chunk(entries, params.config.size);
  return sitemaps.map((urls) => buildSitemapXml(urls, params.config.format));
}
function buildSitemapIndex(sitemaps, config) {
  const builder = new import_fast_xml_parser.XMLBuilder({
    suppressEmptyNode: true,
    ignoreAttributes: false,
    processEntities: false,
    format: config.format
  });
  return builder.build({
    "?xml": {
      "@_version": "1.0",
      "@_encoding": "UTF-8"
    },
    sitemapindex: {
      "@_xmlns": "http://www.sitemaps.org/schemas/sitemap/0.9",
      sitemap: sitemaps.map((sitemap) => ({
        loc: (0, import_ufo2.cleanDoubleSlashes)(`${config.siteUrl}/${sitemap}`)
      }))
    }
  });
}

// src/bin/routes.ts
var import_config = require("@remix-run/dev/dist/config.js");
var import_path2 = __toESM(require("path"));

// src/bin/moduleBuilder.ts
var import_esbuild = require("esbuild");
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
var dir = import_path.default.resolve(process.cwd());
var cleanAssetsPlugin = {
  name: "clean-assets",
  setup(build2) {
    build2.onResolve(
      {
        filter: /\.(png|jpg|jpeg|gif|svg|webp|ico|woff|woff2|ttf|otf|eot|mp4|webm|wav|mp3|m4a|aac|oga|pdf)$/
      },
      (args) => ({
        path: args.path,
        namespace: "clean-assets"
      })
    );
    build2.onLoad({ filter: /.*/, namespace: "clean-assets" }, () => ({
      contents: "",
      loader: "js"
    }));
  }
};
var cleanStylesPlugin = {
  name: "clean-styles",
  setup(build2) {
    build2.onResolve({ filter: /\.css$/ }, (args) => ({
      path: args.path,
      namespace: "clean-styles"
    }));
    build2.onLoad({ filter: /.*/, namespace: "clean-styles" }, () => ({
      contents: "",
      loader: "js"
    }));
  }
};
async function createModuleBuilder() {
  const plugins = [cleanStylesPlugin, cleanAssetsPlugin];
  const tsconfig = import_path.default.resolve(dir, "tsconfig.json");
  const isTsProject = import_fs.default.existsSync(tsconfig);
  if (isTsProject) {
    const { TsconfigPathsPlugin } = await import("@esbuild-plugins/tsconfig-paths");
    plugins.push(TsconfigPathsPlugin({ tsconfig }));
  }
  return {
    buildModule: (file) => buildModule(file, plugins)
  };
}
function buildModule(file, plugins) {
  return (0, import_esbuild.build)({
    entryPoints: [file],
    platform: "neutral",
    format: "cjs",
    outfile: "out.js",
    write: false,
    bundle: true,
    packages: "external",
    loader: {
      ".js": "jsx"
    },
    logLevel: "silent",
    plugins
  });
}

// src/bin/routes.ts
var import_require_from_string = __toESM(require("require-from-string"));
var dir2 = import_path2.default.resolve(process.cwd());
async function getRoutesAndModules() {
  const config = await (0, import_config.readConfig)(process.env.REMIX_ROOT || dir2);
  const routes = config.routes;
  const modules = {};
  console.log("\u{1F50D} Found routes: " + Object.keys(routes).join(", "));
  const { buildModule: buildModule2 } = await createModuleBuilder();
  await Promise.all(
    Object.keys(routes).map(async (key) => {
      const route = routes[key];
      if (key === "root")
        return;
      const file = import_path2.default.resolve(config.appDirectory, route.file);
      const result = await buildModule2(file);
      const module2 = (0, import_require_from_string.default)(result.outputFiles[0].text);
      modules[key] = module2;
    })
  );
  return {
    routes,
    modules
  };
}

// src/lib/config.ts
var getConfig = (config) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    ...config,
    autoLastmod: (_a = config.autoLastmod) != null ? _a : true,
    changefreq: (_b = config.changefreq) != null ? _b : "daily",
    priority: (_c = config.priority) != null ? _c : 0.7,
    sitemapBaseFileName: (_d = config.sitemapBaseFileName) != null ? _d : "sitemap",
    generateIndexSitemap: (_e = config.generateIndexSitemap) != null ? _e : true,
    outDir: (_f = config.outDir) != null ? _f : "public",
    robotsTxtOptions: {
      ...config.robotsTxtOptions || {},
      policies: (_h = (_g = config.robotsTxtOptions) == null ? void 0 : _g.policies) != null ? _h : [
        {
          userAgent: "*",
          allow: "/"
        }
      ]
    }
  };
};

// src/bin/polyfill.ts
var import_isomorphic_fetch = require("isomorphic-fetch");

// src/bin/files.ts
var import_fs2 = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));

// src/robots.ts
function getPolicy(policy) {
  const { allow, disallow, userAgent } = policy;
  let policyStr = `# ${userAgent}
User-agent: ${userAgent}`;
  if (allow) {
    const allowStr = Array.isArray(allow) ? allow.join("\nAllow: ") : allow;
    policyStr += `
Allow: ${allowStr}`;
  }
  if (disallow) {
    const disallowStr = Array.isArray(disallow) ? disallow.join("\nDisallow: ") : disallow;
    policyStr += `
Disallow: ${disallowStr}`;
  }
  return policyStr;
}
function getSitemap(sitemap) {
  return `Sitemap: ${sitemap}`;
}
function getRobots(config) {
  var _a;
  const options = config.robotsTxtOptions;
  let str = "";
  const policies = (_a = options == null ? void 0 : options.policies) == null ? void 0 : _a.map(getPolicy);
  if (policies == null ? void 0 : policies.length) {
    str += policies.join("\n\n");
    str += "\n\n";
  }
  str += `# Host
Host: ${config.siteUrl}

`;
  const sitemaps = [`${config.siteUrl}/${config.sitemapBaseFileName}.xml`].concat((options == null ? void 0 : options.additionalSitemaps) || []).map(getSitemap);
  if (sitemaps == null ? void 0 : sitemaps.length) {
    str += "# Sitemaps\n";
    str += sitemaps.join("\n");
  }
  return str;
}

// src/bin/files.ts
var dir3 = process.cwd();
function createIndexSitemapFile(sitemap, config) {
  const sitemaps = Array.isArray(sitemap) ? sitemap.map((_, index) => `${config.sitemapBaseFileName}-${index}.xml`) : [`${config.sitemapBaseFileName}-0.xml`];
  const sitemapIndex = buildSitemapIndex(sitemaps, config);
  import_fs2.default.writeFileSync(import_path3.default.join(dir3, config.outDir, "sitemap.xml"), sitemapIndex);
}
function createSitemapFiles(sitemap, config) {
  if (Array.isArray(sitemap)) {
    sitemap.forEach((content, index) => {
      import_fs2.default.writeFileSync(
        import_path3.default.join(
          dir3,
          config.outDir,
          `${config.sitemapBaseFileName}-${index}.xml`
        ),
        content
      );
    });
  } else {
    const filename = config.generateIndexSitemap ? `${config.sitemapBaseFileName}-0.xml` : `${config.sitemapBaseFileName}.xml`;
    import_fs2.default.writeFileSync(import_path3.default.join(dir3, config.outDir, filename), sitemap);
  }
}
function createRobotsFile(config) {
  const robots = getRobots(config);
  import_fs2.default.writeFileSync(import_path3.default.join(dir3, config.outDir, "robots.txt"), robots);
}
function deleteOldSitemaps(config) {
  const files = import_fs2.default.readdirSync(import_path3.default.join(dir3, config.outDir));
  const sitemaps = files.filter(
    (file) => file.startsWith(config.sitemapBaseFileName)
  );
  sitemaps.forEach((sitemap) => {
    import_fs2.default.unlinkSync(import_path3.default.join(dir3, config.outDir, sitemap));
  });
}

// src/bin/index.ts
var import_url = require("url");
var findConfig = () => {
  const configPath = import_path4.default.resolve(process.cwd(), "remix-sitemap.config.js");
  if (import_fs3.default.existsSync(configPath))
    return (0, import_url.pathToFileURL)(configPath).toString();
};
async function main() {
  const configPath = findConfig();
  if (!configPath) {
    console.error("\u274C No config file found");
    return;
  }
  console.log("\u{1F50D} Found config file:", configPath);
  const { default: configFile } = await import(configPath);
  const config = getConfig(configFile);
  console.log("\u{1F50D} Generating sitemap...");
  const { routes, modules } = await getRoutesAndModules();
  const params = {
    config,
    context: {
      routeModules: modules,
      manifest: {
        routes
      }
    },
    request: {}
  };
  const isSplitted = config.size && config.size > 0;
  const sitemap = isSplitted ? await buildSitemaps(params) : await buildSitemap(params);
  if (config.generateRobotsTxt) {
    createRobotsFile(config);
  }
  deleteOldSitemaps(config);
  if (config.generateIndexSitemap) {
    createIndexSitemapFile(sitemap, config);
  }
  createSitemapFiles(sitemap, config);
  console.log("\u2728 Sitemap generated successfully");
}
main();
