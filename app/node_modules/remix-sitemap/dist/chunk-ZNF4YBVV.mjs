// src/utils/validations.ts
import { isEqual } from "ufo";

// src/utils/data.ts
function getRouteData(route, context) {
  var _a;
  const manifest = context.manifest.routes[route];
  const module = context.routeModules[route];
  const path = getFullPath(route, context.manifest.routes);
  const parents = (_a = manifest.id) == null ? void 0 : _a.split("/").slice(0, -1);
  const parentId = parents.join("/");
  return {
    manifest,
    module,
    modules: context.routeModules,
    sitemapFunction: module == null ? void 0 : module.sitemap,
    path,
    parents,
    parentId
  };
}
function getFullPath(route, routes) {
  const manifest = routes[route];
  if (manifest.index) {
    const parent2 = getFullPath(manifest.parentId || "root", routes);
    if (!manifest.path && !parent2)
      return "";
    if (manifest.path && parent2)
      return `${parent2}/${manifest.path}`;
    return manifest.path;
  }
  if (!manifest.parentId || manifest.parentId === "root" || !manifest.path)
    return manifest.path;
  const parent = getFullPath(manifest.parentId, routes);
  if (parent)
    return `${parent}/${manifest.path}`;
  return manifest.path;
}

// src/utils/validations.ts
function isSitemapUrl(config, request) {
  const url = new URL(request.url);
  return isEqual(url.pathname, `/${config.sitemapBaseFileName}.xml`);
}
var isDynamicPath = (path) => (path == null ? void 0 : path.includes(":")) || (path == null ? void 0 : path.includes("*"));
var isRobotsUrl = (request) => {
  const url = new URL(request.url);
  return isEqual(url.pathname, `/robots.txt`);
};
function isValidEntry(route, context) {
  const { manifest, path, module, sitemapFunction } = getRouteData(
    route,
    context
  );
  if (manifest.id === "root")
    return false;
  if (typeof path === "undefined" && !sitemapFunction)
    return false;
  if (!module.default && !sitemapFunction)
    return false;
  if (isDynamicPath(path) && !sitemapFunction)
    return false;
  return true;
}

// src/builders/sitemap.ts
import { cleanDoubleSlashes } from "ufo";
import { XMLBuilder } from "fast-xml-parser";

// src/utils/xml.ts
var getBooleanValue = (value) => typeof value !== "boolean" ? void 0 : value ? "yes" : "no";
function getOptionalValue(value, returnType) {
  return !value ? void 0 : returnType;
}

// src/utils/rate-limiter.ts
var RateLimiter = class {
  constructor(rate) {
    this.rate = rate;
    this.queue = [];
    this.active = 0;
  }
  allocate() {
    return new Promise((res) => {
      if (this.active < this.rate) {
        this.active++;
        res();
      } else {
        this.queue.push(res);
      }
    });
  }
  free() {
    const first = this.queue.shift();
    if (first) {
      first();
    } else {
      this.active = Math.max(0, this.active - 1);
    }
  }
  getProcessing() {
    return this.active;
  }
  getWaiting() {
    return this.queue.length;
  }
};

// src/utils/entries.ts
async function getEntry(params) {
  const { route, context, request, config } = params;
  if (!isValidEntry(route, context))
    return null;
  const { sitemapFunction, path } = getRouteData(route, context);
  const sitemap = sitemapFunction ? await sitemapFunction({ request, config }) : null;
  if (sitemap) {
    if (Array.isArray(sitemap)) {
      const notExcluded = sitemap.filter((entry) => !entry.exclude);
      return notExcluded.map((entry) => buildSitemapUrl({ config, entry }));
    }
    if (sitemap.exclude)
      return null;
    return buildSitemapUrl({
      config,
      entry: { ...sitemap, loc: sitemap.loc || path }
    });
  }
  return buildSitemapUrl({ config, entry: { loc: path } });
}

// src/utils/truthy.ts
function truthy(value) {
  return !!value;
}

// src/utils/chunk.ts
function chunk(arr, chunkSize) {
  const R = [];
  for (let i = 0, len = arr.length; i < len; i += chunkSize)
    R.push(arr.slice(i, i + chunkSize));
  return R;
}

// src/builders/sitemap.ts
var getAlternateRef = (alternateRefs) => ({
  "@_rel": "alternate",
  "@_hreflang": alternateRefs.hreflang,
  "@_href": cleanDoubleSlashes(alternateRefs.href)
});
var getImage = (image) => ({
  "image:loc": image.loc
});
var getVideo = (video) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  return {
    "video:thumbnail_loc": video.thumbnailLoc,
    "video:title": video.title,
    "video:description": video.description,
    "video:content_loc": video.contentLoc,
    "video:player_loc": video.playerLoc,
    "video:duration": video.duration,
    "video:expiration_date": video.expirationDate,
    "video:rating": video.rating,
    "video:view_count": video.viewCount,
    "video:publication_date": video.publicationDate,
    "video:family_friendly": getBooleanValue(video.familyFriendly),
    "video:restriction": getOptionalValue(video.restriction, {
      "@_relationship": (_a = video.restriction) == null ? void 0 : _a.relationship,
      "#text": (_b = video.restriction) == null ? void 0 : _b.countries.join(" ")
    }),
    "video:price": getOptionalValue(video.price, {
      "@_currency": (_c = video.price) == null ? void 0 : _c.currency,
      "#text": (_d = video.price) == null ? void 0 : _d.value
    }),
    "video:requires_subscription": getBooleanValue(video.requiresSubscription),
    "video:platform": getOptionalValue(video.platform, {
      "@_relationship": (_e = video.platform) == null ? void 0 : _e.relationship,
      "#text": (_g = (_f = video.platform) == null ? void 0 : _f.content) == null ? void 0 : _g.join(" ")
    }),
    "video:uploader": getOptionalValue(video.uploader, {
      "@_info": (_h = video.uploader) == null ? void 0 : _h.info,
      "#text": (_i = video.uploader) == null ? void 0 : _i.name
    }),
    "video:live": getBooleanValue(video.live),
    "video:tag": video.tags
  };
};
var getNews = (news) => ({
  "news:publication": {
    "news:name": news.publication.name,
    "news:language": news.publication.language
  },
  "news:publication_date": news.date,
  "news:title": news.title
});
var getUrl = (entry) => {
  var _a, _b, _c, _d;
  return {
    loc: cleanDoubleSlashes(entry.loc),
    lastmod: entry.lastmod,
    changefreq: entry.changefreq,
    priority: entry.priority,
    "xhtml:link": (_a = entry.alternateRefs) == null ? void 0 : _a.map(getAlternateRef),
    "image:image": (_b = entry.images) == null ? void 0 : _b.map(getImage),
    "news:news": (_c = entry.news) == null ? void 0 : _c.map(getNews),
    "video:video": (_d = entry.videos) == null ? void 0 : _d.map(getVideo)
  };
};
function buildSitemapUrl({ config, entry }) {
  var _a, _b, _c, _d;
  const alternateRefs = (_a = (entry == null ? void 0 : entry.alternateRefs) || config.alternateRefs) == null ? void 0 : _a.map(
    (ref) => ({
      ...ref,
      href: ref.absolute ? ref.href : `${ref.href}/${entry == null ? void 0 : entry.loc}`
    })
  );
  const url = getUrl({
    loc: `${config.siteUrl}/${entry == null ? void 0 : entry.loc}`,
    lastmod: config.autoLastmod ? (_b = entry == null ? void 0 : entry.lastmod) != null ? _b : (/* @__PURE__ */ new Date()).toISOString() : entry == null ? void 0 : entry.lastmod,
    changefreq: (_c = entry == null ? void 0 : entry.changefreq) != null ? _c : config.changefreq,
    priority: (_d = entry == null ? void 0 : entry.priority) != null ? _d : config.priority,
    alternateRefs,
    videos: entry == null ? void 0 : entry.videos,
    images: entry == null ? void 0 : entry.images,
    news: entry == null ? void 0 : entry.news
  });
  return url;
}
function buildSitemapXml(urlset, format) {
  const builder = new XMLBuilder({
    suppressEmptyNode: true,
    ignoreAttributes: false,
    processEntities: true,
    format
  });
  return builder.build({
    "?xml": {
      "@_version": "1.0",
      "@_encoding": "UTF-8"
    },
    urlset: {
      "@_xmlns": "http://www.sitemaps.org/schemas/sitemap/0.9",
      "@_xmlns:news": "http://www.google.com/schemas/sitemap-news/0.9",
      "@_xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "@_xmlns:image": "http://www.google.com/schemas/sitemap-image/1.1",
      "@_xmlns:video": "http://www.google.com/schemas/sitemap-video/1.1",
      url: urlset
    }
  });
}
async function IngestRoutes(params) {
  const { config, context, request } = params;
  const routes = Object.keys(context.manifest.routes);
  if (config.rateLimit) {
    const limiter = new RateLimiter(config.rateLimit);
    const entriesPromise = routes.map(async (route) => {
      await limiter.allocate();
      const out = await getEntry({ route, config, context, request });
      limiter.free();
      return out;
    });
    return (await Promise.all(entriesPromise)).flat().filter(truthy);
  } else {
    const entriesPromise = routes.map(
      (route) => getEntry({ route, config, context, request })
    );
    return (await Promise.all(entriesPromise)).flat().filter(truthy);
  }
}
async function buildSitemap(params) {
  const entries = await IngestRoutes(params);
  return buildSitemapXml(entries, params.config.format);
}
async function buildSitemaps(params) {
  if (!params.config.size)
    throw new Error("You must specify a size for sitemap splitting");
  const entries = await IngestRoutes(params);
  const sitemaps = chunk(entries, params.config.size);
  return sitemaps.map((urls) => buildSitemapXml(urls, params.config.format));
}
function buildSitemapIndex(sitemaps, config) {
  const builder = new XMLBuilder({
    suppressEmptyNode: true,
    ignoreAttributes: false,
    processEntities: false,
    format: config.format
  });
  return builder.build({
    "?xml": {
      "@_version": "1.0",
      "@_encoding": "UTF-8"
    },
    sitemapindex: {
      "@_xmlns": "http://www.sitemaps.org/schemas/sitemap/0.9",
      sitemap: sitemaps.map((sitemap) => ({
        loc: cleanDoubleSlashes(`${config.siteUrl}/${sitemap}`)
      }))
    }
  });
}

// src/lib/config.ts
var getConfig = (config) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  return {
    ...config,
    autoLastmod: (_a = config.autoLastmod) != null ? _a : true,
    changefreq: (_b = config.changefreq) != null ? _b : "daily",
    priority: (_c = config.priority) != null ? _c : 0.7,
    sitemapBaseFileName: (_d = config.sitemapBaseFileName) != null ? _d : "sitemap",
    generateIndexSitemap: (_e = config.generateIndexSitemap) != null ? _e : true,
    outDir: (_f = config.outDir) != null ? _f : "public",
    robotsTxtOptions: {
      ...config.robotsTxtOptions || {},
      policies: (_h = (_g = config.robotsTxtOptions) == null ? void 0 : _g.policies) != null ? _h : [
        {
          userAgent: "*",
          allow: "/"
        }
      ]
    }
  };
};

// src/robots.ts
function getPolicy(policy) {
  const { allow, disallow, userAgent } = policy;
  let policyStr = `# ${userAgent}
User-agent: ${userAgent}`;
  if (allow) {
    const allowStr = Array.isArray(allow) ? allow.join("\nAllow: ") : allow;
    policyStr += `
Allow: ${allowStr}`;
  }
  if (disallow) {
    const disallowStr = Array.isArray(disallow) ? disallow.join("\nDisallow: ") : disallow;
    policyStr += `
Disallow: ${disallowStr}`;
  }
  return policyStr;
}
function getSitemap(sitemap) {
  return `Sitemap: ${sitemap}`;
}
function getRobots(config) {
  var _a;
  const options = config.robotsTxtOptions;
  let str = "";
  const policies = (_a = options == null ? void 0 : options.policies) == null ? void 0 : _a.map(getPolicy);
  if (policies == null ? void 0 : policies.length) {
    str += policies.join("\n\n");
    str += "\n\n";
  }
  str += `# Host
Host: ${config.siteUrl}

`;
  const sitemaps = [`${config.siteUrl}/${config.sitemapBaseFileName}.xml`].concat((options == null ? void 0 : options.additionalSitemaps) || []).map(getSitemap);
  if (sitemaps == null ? void 0 : sitemaps.length) {
    str += "# Sitemaps\n";
    str += sitemaps.join("\n");
  }
  return str;
}
function robotsResponse(config) {
  const robots = getRobots(config);
  if (!robots)
    return;
  const bytes = new TextEncoder().encode(robots).byteLength;
  return new Response(robots, {
    headers: {
      ...config.headers || {},
      "Content-Type": "text/plain",
      "Content-Length": bytes.toString()
    }
  });
}

export {
  isSitemapUrl,
  isRobotsUrl,
  buildSitemap,
  buildSitemaps,
  buildSitemapIndex,
  getConfig,
  getRobots,
  robotsResponse
};
